\chapter{实现与性能测试}
\label{chap:test}

\section{实现}
根据前面的设计，本文实现了一个定理自动证明器。由于时间所限，并没有实现所有功能。该证明器的特性如下：
\begin{itemize}
  \item 采用C语言编写。
  \item 实现了SMT结构的证明器，支持等词与未解释函数理论、线性整数理论。
  \item 理论整合部分采用推出式\footnote{见第\ref{chap:no}章的实现部分。}，部分形式的命题会有不停机的问题。
  \item 支持Coq兼容的证明项生成。但理论证明部分，证明项生成没有完全实现，部分证明项生成生成工作由Coq的tactic代理。
  \item 未实现分离逻辑命题证明部分。
\end{itemize}

由于该证明器未实现分离逻辑，因此还不能叫做分离逻辑的定理证明器。但是，由于分离逻辑部分主要是将命题转化为一阶逻辑命题求证，因此对于验证设计中可信性、自动化的目标，以及评价性能，仍然具有意义。

\section{性能测试}
\subsection{测试对象}
我们选择Z3和Coq与本文的实现作对比。其中，本文的实现与Z3都是SMT结构，而Z3是实现最好的SMT证明器之一，故可作速度上限。而本文的实现在判定命题时，应比Coq的判定快，否则便失去了在Coq外部做证明的意义。

测试的指标有两个：\emph{判定时间}和\emph{证明项编译时间}。前者是指命题输入到宣告命题成立所需要的时间，后者是指Coq兼容的证明项输出被Coq的编译器检查所需要的时间。

对于本文的实现，两个测试指标都是有意义的。而对Z3来说，因为没有证明项输出，因此只有判定时间。对Coq来说，判定与证明项的编译是同时发生的。因此，以下对Z3和Coq的两种时间不作区分，都只称时间。

\subsection{测试数据的选取}
测试数据的选取有两个原则：使用适度的规模和保证代表性。

使用适度的规模的测试数据，是指数据规模既不能太小，也不能太大。数据规模太小，三个系统运行的时间都很短，时间不易测准；而规模太大，Coq在判定或编译证明项时容易超时超内存。

保证代表性，是指各种理论都有测试数据覆盖到。注意到Coq只能对纯理论的命题做自动判定，而不支持混合理论的命题。故还要有纯理论的例子出现，以测试Coq的固有能力。对于混合理论命题，则先由人工给出Coq证明脚本，再测试时间。

根据以上原则，本文一共设计了六组测试数据，分别编号为$1$到$6$。其简要描述如表\ref{tab:test}：
\begin{table}[!ht]
  \caption{测试数据的描述}
  \label{tab:test}
  \centering
  \begin{tabular}{clc}
    \whline
    编号 & 测试内容 & Coq 自动化策略\\
    \whline
    1 & 命题逻辑，常见重言式 & \texttt{tauto} \\
    2 & 命题逻辑，5变量CNF范式 & \texttt{tauto} \\
    3 & 命题逻辑，8变量3-SAT问题 & \texttt{tauto} \\
    4 & 纯线性整数理论 & \texttt{omega} \\
    5 & 等词与未解释函数理论 & \texttt{congruence} \\
    6 & 混合理论 & 人工编写脚本 \\
    \whline
  \end{tabular}
\end{table}

\subsection{测试结果}
测试采用如下平台：
\begin{itemize}
  \item CPU: Intel Core i3 330M
  \item Mem: 4G
  \item Kernel: Linux 3.8.8-x86\_64
  \item Compiler: GCC 4.7.2, OCAML 4.00.1
  \item Z3 4.3.1, Coq 8.4p1
\end{itemize}

测试结果如表\ref{tab:res}，其中时间精度为0.01秒，有效位数2位。
\begin{table}[!ht]
  \caption{测试结果，单位：秒}
  \label{tab:res}
  \centering
  \begin{tabular}{crrrr}
    \whline
    编号 & 本文判定 & Coq & Z3 & 本文编译 \\
    \whline
    1 & 0.01 & 0.06 & <0.01 & 27 \\
    2 & <0.01 & 0.32 & <0.01 & 0.14 \\
    3 & 0.05 & 超内存 & 0.01 & 110 \\
    4 & 0.03 & 0.17 & 0.01 & 3.9 \\
    5 & <0.01 & 0.01 & <0.01 & 0.75 \\
    6 & 0.02 & 0.86 & 0.01 & 2.3 \\
    \whline
  \end{tabular}
\end{table}

\subsection{讨论}
若用本文实现的判定时间与Coq和Z3的时间做对比，则介于两种证明器之间，本文实现的速度较Coq具有一定优势。特别是对于SAT问题，Coq的\texttt{tauto}策略往往在规模稍大时就会超时超内存，而本文的实现则能够证明。另外，Z3在证明上述数据时，几乎都能在最小时间单位内证出。这说明本文的实现还有较大提升空间。

但是考虑到Coq的时间实际上包括判定时间和证明项编译时间，则本文的实现情况还很不理想。

最坏时间出现在数据1，本文的实现总时间是Coq的几百倍。经过对生成证明项的考察，得到如下原因：
\begin{enumerate}
  \item 数据1的蕴含式较多，在证明式规范到CNF时出现了98个CNF子句，这些子句的证明项占用了总证明项的98\%，使Coq编译时负担较大。
  \item SAT求解时，迟迟得不到矛盾，造成生成的证明项函数嵌套层数过多、体积过大。Coq对于这种类型的证明项验证较慢，消耗内存很多，因此减慢了速度。
\end{enumerate}

数据4慢的原因是，当前对线性整数理论的证明项生成通过Coq的\texttt{omega}实现。这在证明器完善后将有效缓解。

数据6慢的原因是，本文自动生成的证明项比不过人工编写的脚本。

\section{结论}
本章的实现与测试说明：
\begin{enumerate}
  \item 本文设计的证明器具有可行性，单纯判定命题时的性能指标优于Coq，并且比Coq的自动化程度更高。
  \item 本文实现的证明器在生成证明项方面还不够好，其编译时间过长。解决这个问题，需要由以下方面着手：
    \begin{enumerate}
      \item 优化决策过程。虽然判定的性能指标基本能够满足要求，但是未优化的决策过程搜索过多，导致证明项庞大。
      \item 避免生成Coq不擅长的证明项类型。目前观察到，对过多嵌套的函数，Coq在编译时容易超时超内存。而对连续的结构较简单的引理，Coq编译速度较快。
      \item 进一步浓缩证明项。可考虑在证明项生成后，加入浓缩处理，如删除冗余、合并公共表达式等。而这可以通过借鉴编译技术的相关内容解决。
    \end{enumerate}
\end{enumerate}
